# ðŸ¥· **Assignment 5-1**

>Source file: `src/TTT/A5.hs`

* **Q#01**:
  * Write an action `printBoard` that takes a `Board` value, formats it using `formatBoard`, and prints the resulting string to the terminal.
  * Test `printBoard` in a GHCi REPL session:
    ```shell
    $ cabal repl

    Main> :l TTT.A5

    TTT.A5> printBoard _TIED_BOARD_
     _|_0_|_1_|_2_|_
    A_|_X_|_O_|_O_|_
    B_|_O_|_X_|_X_|_
    C_|_O_|_X_|_O_|_
    TTT.A5> printBoard _EMPTY_BOARD_
     _|_0_|_1_|_2_|_
    A_|___|___|___|_
    B_|___|___|___|_
    C_|___|___|___|_
    ```

* **Q#02**:
  * Write an action `printLogo` that reads the logo art from an external `.txt` file and prints it to the terminal.
  * Use the built-in `readFile` action and the provided `_LOGO_PATH_` constant to read the logo contents as an `IO String` value.
  * Apply the appropriate adapter and built-in action to print the result of `readFile`.
  * Test `printLogo` in your REPL session (view full-screen to see the correct output):
    ```shell
    TTT.A5> :r

    TTT.A5> printLogo
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
    â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•      â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•      â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â•šâ•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•— â•šâ•â•â•â•â•   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•
       â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•—         â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
       â•šâ•â•   â•šâ•â• â•šâ•â•â•â•â•â•      â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•         â•šâ•â•    â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•
    ```

* **Q#03**:
  * Write an action `firstPlayer` which composes the provided `_RANDOM_BOOL` constant with a lambda expression that applies `getFirstPlayer` and returns the corresponding `Player` value in the `IO` context.
  * Test `firstPlayer` several times in your REPL session. It should produce varying `X` and `O` results.

* **Q#04**:
  * Write an action `getMove` that takes a `Board` value as input, receives a move string from the user, validates the move, and then does one of the following:
    * If the move is valid, return it in the `IO` context
    * If not, print an appropriate error string that requests the user to try again, and call `getMove` again (which adapter should be used to compose these two actions?)
  * You'll need to use your `isValidMove` and `stringToMove` functions in your solution.
  * Use the worker-wrapper idiom:
    * The outer ("wrapper") action should get the user string and apply a worker action to it using the appropriate adapter.
    * The worker should convert the input string to a `Move` value, validate it, and use conditional logic to return an appropriate expression (corresponding to one of the two cases outlined above).
  * Test `getMove` in your REPL session (use `CTRL + c` to exit the action if you get stuck!):
    ```shell
    TTT.A5> :r

    TTT.A5> getMove _EMPTY_BOARD_
    d3
    Invalid move! Try again
    b1
    (1,1)
    TTT.A5> getMove _TIED_BOARD_
    a0
    Invalid move! Try again
    ^CInterrupted.
    TTT.A5>
    ```

* **Q#05**:
  * Write an action `play` that takes a `Board` and `Player` value. This will be the central "game loop" action that executes the game logic.
  * `play` should do the following in sequence:
    1. Check the value of `_DISPLAY_LOGO_` and run the `printLogo` action if `True` (which action enables conditional execution like this?)
    2. Print the current board.
    3. Print a message prompting the current player to play (use the `promptPlayer` function you defined in `A2`).
    4. Get a move from the player, and apply a worker action to it using the appropriate adapter.
      * The worker action should apply the `playMove` function from `A4` and use conditional logic based on the result.
      * If the resulting `GameState` indicates that the game is still in progress, `play` should be called again with the updated `Board` and the opposite `Player` value (recall the `switchPlayer` function you wrote for this purpose).
      * For any other `GameState` (in which the game has ended), you should print the final board using `printBoard` again as well as the appropriate message produced by applying the `showGameState` function you wrote in `A1`. At this point no further action is required and the game should terminate.
  * We'll test this action in `Q#06`, when we're ready to play our game.

* **Q#06**:
  * Replace the body of the `runTTT` action to make it do the following:
    * Partially apply the `play` action to `_EMPTY_BOARD_` to create a new action
    * Apply this action to `firstPlayer` using the appropriate adapter
  * Test your game by exiting your REPL session, calling `cabal run` and selecting `1`:
    ```shell
    TTT.A5> :q

    $ cabal run
    
    ```
  * The game should now compile and run correctly from start to finish.